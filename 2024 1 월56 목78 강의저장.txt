

==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 4:20:06
==================================================

//-----------------------
//목78
// 5.2 목
// list - 자기가 잘 하는 동작을 멤버함수로 제공한다
//		  sort, remove, unique, merge, (splice)
//		  전역 알고리즘 함수가 있더라도 이 함수들을 list가 제공하는 이유를 생각해보자
//----------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");
	관찰 = true;

	// 리스트가 잘할 수 있는 동작 - merge
	list <String> con1{"민준", "서준", "하준"};
	list <String> con2{"도윤", "시우", "은우", "지호"};

	//merge(con1.begin(), con1.end(), con2.begin(), con2.end(), ostream_iterator<String>{cout, "\n"});
 }


==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 4:20:12
==================================================

//-----------------------
//목78
// 5.2 목
// list - 자기가 잘 하는 동작을 멤버함수로 제공한다
//		  sort, remove, unique, merge, (splice)
//		  전역 알고리즘 함수가 있더라도 이 함수들을 list가 제공하는 이유를 생각해보자
//----------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");
	관찰 = true;

	// 리스트가 잘할 수 있는 동작 - merge
	list <String> con1{"민준", "서준", "하준"};
	list <String> con2{"도윤", "시우", "은우", "지호"};

	//merge(con1.begin(), con1.end(), con2.begin(), con2.end(), ostream_iterator<String>{cout, "\n"});
 }


==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 4:28:47
==================================================

//-----------------------
//목78
// 5.2 목
// list - 자기가 잘 하는 동작을 멤버함수로 제공한다
//		  sort, remove, unique, merge, (splice)
//		  전역 알고리즘 함수가 있더라도 이 함수들을 list가 제공하는 이유를 생각해보자
//----------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");
	관찰 = true;

	// 리스트가 잘할 수 있는 동작 - merge
	list <string> con1{"민준", "서준", "하준"};
	list <string> con2{"도윤", "시우", "은우", "지호"};

	merge(con1.begin(), con1.end(), con2.begin(), con2.end(), ostream_iterator<string>{cout, "\n"});
 }


==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 4:43:39
==================================================

//-----------------------
//목78
// 5.2 목
// list - 자기가 잘 하는 동작을 멤버함수로 제공한다
//		  sort, remove, unique, merge, (splice)
//		  전역 알고리즘 함수가 있더라도 이 함수들을 list가 제공하는 이유를 생각해보자
//----------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");
	관찰 = true;

	// 리스트가 잘할 수 있는 동작 - merge
	list <String> con1{"민준", "서준", "하준"};
	list <String> con2{"도윤", "시우", "은우", "지호"};

	con1.merge(con2);

	for (const String& s : con1)
		cout << s << " ";

	cout << endl;
	cout << "merge된 컨테이너" << endl;
	for (const String& s : con2)
		cout << s << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 4:44:37
==================================================

//-----------------------
//목78
// 5.2 목
// list - 자기가 잘 하는 동작을 멤버함수로 제공한다
//		  sort, remove, unique, merge, (splice)
//		  전역 알고리즘 함수가 있더라도 이 함수들을 list가 제공하는 이유를 생각해보자
//----------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 리스트가 잘할 수 있는 동작 - merge
	list <String> con1{"민준", "서준", "하준"};
	list <String> con2{"도윤", "시우", "은우", "지호"};

	관찰 = true;
	con1.merge(con2);

	for (const String& s : con1)
		cout << s << " ";

	cout << endl;
	cout << "merge된 컨테이너" << endl;
	for (const String& s : con2)
		cout << s << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 4:44:57
==================================================

//-----------------------
//목78
// 5.2 목
// list - 자기가 잘 하는 동작을 멤버함수로 제공한다
//		  sort, remove, unique, merge, (splice)
//		  전역 알고리즘 함수가 있더라도 이 함수들을 list가 제공하는 이유를 생각해보자
//----------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 리스트가 잘할 수 있는 동작 - merge
	list <String> con1{"민준", "서준", "하준"};
	list <String> con2{"도윤", "시우", "은우", "지호"};

	관찰 = true;
	con1.merge(con2);
	관찰 = false;

	for (const String& s : con1)
		cout << s << " ";

	cout << endl;
	cout << "merge된 컨테이너" << endl;
	for (const String& s : con2)
		cout << s << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 4:56:01
==================================================

//-----------------------
//목78
// 5.2 목
// list - 자기가 잘 하는 동작을 멤버함수로 제공한다
//		  sort, remove, unique, merge, (splice)
//		  전역 알고리즘 함수가 있더라도 이 함수들을 list가 제공하는 이유를 생각해보자
//----------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <string>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 문제
	// FileName.cpp에 있는 소문자를 list<char>에 저장하라.
	// 저장한 문자가 [a, z]까지 모든 문자가 있는지 확인하라.

	ifstream in{ "FileName.cpp" };

	if (!in)
		return -1;

	list<char> con;

	char c;
	while (in >> c) {
		if (islower(c))
			con.push_back(c);
	}

	con.sort();
	con.unique();  // 중복된 원소를 삭제한다

	//jy

	if (26 == con.size())  
		cout << "모든 문자 포함" << endl;

	else
		cout << "없는 문자가 있음" << endl;



	for (char& c : con)
		cout << c;
	cout << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-02 목요일 오후 5:11:13
==================================================

//-----------------------
//목78
// 5.2 목
// forward_list - 단일 연결 리스트가 필요하다면 이걸 써라.
//                이것보다 더 좋은 걸 만들 수는 없을 것이다.
// 
// It is intended that forward_list have zero space or time overhead relative to 
// a hand-written C-style singly linked list.
// Features that would conflict with that goal have been omitted.
//----------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 1:54:59
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 반복자는 객체입니다.
	// 출력 스트림 반복자(반복자 어댑터의 일종: 스트림 반복자)를 사용하여 동작을 이해해 본다.

	
	ostream_iterator<char> p{ cout };
	cout << "출력 스트림 반복자의 크기 - " << sizeof(p) << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 1:57:59
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 반복자는 객체입니다.
	// 출력 스트림 반복자(반복자 어댑터의 일종: 스트림 반복자)를 사용하여 동작을 이해해 본다.

	
	ostream_iterator<char> p{ cout };
	cout << "출력 스트림 반복자의 크기 - " << sizeof(p) << endl;

	*p = 'A';

	++p;

	*p = 'B';
	++p;

	*p = 'C';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 1:58:10
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 반복자는 객체입니다.
	// 출력 스트림 반복자(반복자 어댑터의 일종: 스트림 반복자)를 사용하여 동작을 이해해 본다.

	
	ostream_iterator<char> p{ cout };
	cout << "출력 스트림 반복자의 크기 - " << sizeof(p) << endl;

	*p = 'A';
	++p;

	*p = 'B';
	++p;

	*p = 'C';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:00:45
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 반복자는 객체입니다.
	// 출력 스트림 반복자(반복자 어댑터의 일종: 스트림 반복자)를 사용하여 동작을 이해해 본다.

	
	ostream_iterator<char> p{ cout };
	cout << "출력 스트림 반복자의 크기 - " << sizeof(p) << endl;

	//*p = 'A';
	//++p;

	(p.operator*()).operator = ('A');
	p.operator++();

	*p = 'B';
	++p;

	*p = 'C';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:03:19
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


int main() {
	save("FileName.cpp");

	// 반복자는 객체입니다.
	// 출력 스트림 반복자(반복자 어댑터의 일종: 스트림 반복자)를 사용하여 동작을 이해해 본다.

	
	ostream_iterator<char> p{ cout };

	p = 'A';
	p = 'B';
	p = 'C';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:14:32
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iter).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:15:59
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iter).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	f(3);
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:19:38
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	//f(3);
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:28:22
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	//f(3);
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:28:27
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	//f(3);
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:30:30
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	//f(3);
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:30:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	//f(3);
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:31:11
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	//f(3);
	f(ostream_iterator<char> { cout });
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:34:04
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	f(istream_iterator<String>{ cin });
	f(ostream_iterator<char> { cout });
	f(forward_list<int>{}.cbegin());
	f(list<float>{}.rbegin());
	f(deque<int>::const_iterator{});
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:34:09
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	f(istream_iterator<String>{ cin });
	f(ostream_iterator<char> { cout });
	f(forward_list<int>{}.cbegin());
	f(list<float>{}.rbegin());
	f(deque<int>::const_iterator{});
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:34:31
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	
	f(istream_iterator<String>{ cin });
	f(ostream_iterator<char> { cout });
	f(forward_list<int>{}.cbegin());
	f(list<float>{}.rbegin());
	f(deque<int>::const_iterator{});
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:40:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 반복자 == int일 때 아래 문장은 실패 = SFINAE
	cout << typeid(반복자::iterator_category).name() << endl;

	// 진짜 contiguous 반복자는 다음 문장이 ok
	cout << typeid(반복자::iterator_concept).name() << endl;

}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	// c++ 17에서 추가된 contiguous 반복자 판별은 다른 방식으로 한다,

	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:43:47
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include <array>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 진짜 contiguous 반복자는 다음 문장이 ok
	cout << typeid(반복자::iterator_concept).name() << endl;

}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	// c++ 17에서 추가된 contiguous 반복자 판별은 다른 방식으로 한다,

	//int a[10]{};
//	f(a);
	f(array<int, 10>::iterator{});
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:44:41
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include <array>
#include <string>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 진짜 contiguous 반복자는 다음 문장이 ok
	cout << typeid(반복자::iterator_concept).name() << endl;

}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	// c++ 17에서 추가된 contiguous 반복자 판별은 다른 방식으로 한다,

	//int a[10]{};
//	f(a);
	f(array<int, 10>::iterator{});
	f(string{}.cbegin());
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:48:24
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include <array>
#include <string>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 진짜 contiguous 반복자는 다음 문장이 ok
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	// c++ 17에서 추가된 contiguous 반복자 판별은 다른 방식으로 한다,

	int a[10]{};
	f(a);
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:50:54
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include <array>
#include <string>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 진짜 contiguous 반복자는 다음 문장이 ok
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	// c++ 17에서 추가된 contiguous 반복자 판별은 다른 방식으로 한다,

	int a[10]{};
	f(a);

	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 2:52:25
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>

#include <forward_list>
#include <list>
#include <deque>
#include <vector>
#include <array>
#include <string>

#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");

	// 문제: 반복자는 6가지 종류
	// 반복자를 인자로 받아 어떤 종류인지 출력하는 함수 f()를 작성하라
	// c++ 17에서 추가된 contiguous 반복자 판별은 다른 방식으로 한다,

	int a[10]{};
	f(a);
	f(vector<int>{}.begin());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:03:17
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };

	// 다음 문장이 실행되도록 하라
	for (char s : s)
		cout << s << ' ';
	cout << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:04:43
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };

	// 다음 문장이 실행되도록 하라
	for (char s : s)
		cout << s << ' ';
	cout << endl;

	sort(s.begin(), s.end());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:05:01
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };

	// 다음 문장이 실행되도록 하라
	for (char s : s)
		cout << s << ' ';
	cout << endl;

	sort(s.begin(), s.end());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:05:08
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };

	// 다음 문장이 실행되도록 하라
	for (char s : s)
		cout << s << ' ';
	cout << endl;

	sort(s.begin(), s.end());
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:06:45
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	string s{ "1357924680" };
	
	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:07:06
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	string s{ "1357924680" };

	sort(s.begin(), s.end());
	
	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:07:19
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	string s{ "1357924680" };

	sort(s.begin(), s.end());
	
	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:07:51
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	string s{ "1357924680" };

	sort(s.rbegin(), s.rend());
	
	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:08:34
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	string s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:09:24
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:10:10
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:11:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:16:21
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-06 월요일 오후 3:18:41
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 3:31:30
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 3:58:23
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 3:58:39
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 3:58:43
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 3:59:47
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	// 모든 반복자의 종류를 판별하는 표준 문장
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << ' ';
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 4:15:09
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;
//
//template <class 반복자>
//void f(반복자 iter) {
//	// 모든 반복자의 종류를 판별하는 표준 문장
//	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
//
//}

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	f(s.rbegin());  // 종류와 컨셉을 출력
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 4:16:26
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;
//
//template <class 반복자>
//void f(반복자 iter) {
//	// 모든 반복자의 종류를 판별하는 표준 문장
//	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
//
//}

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// c++20
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	f(s.rbegin());  // 종류와 컨셉을 출력
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 4:23:40
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;
//
//template <class 반복자>
//void f(반복자 iter) {
//	// 모든 반복자의 종류를 판별하는 표준 문장
//	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
//
//}

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// c++20
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	save("FileName.cpp");
	
	String s{ "1357924680" };
	
	f(s.begin());  // 종류와 컨셉을 출력
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 4:25:06
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;
//
//template <class 반복자>
//void f(반복자 iter) {
//	// 모든 반복자의 종류를 판별하는 표준 문장
//	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
//
//}

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// c++20
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	for (auto i = s.begin(); i != s.end(); ++i) {
		cout << *i << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 4:25:21
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;
//
//template <class 반복자>
//void f(반복자 iter) {
//	// 모든 반복자의 종류를 판별하는 표준 문장
//	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
//
//}

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// c++20
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		cout << *i << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 4:25:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;
//
//template <class 반복자>
//void f(반복자 iter) {
//	// 모든 반복자의 종류를 판별하는 표준 문장
//	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
//
//}

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// c++20
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	for (auto i = s.rbegin(); i != s.rend(); ++i) {
		cout << *i << ' ';
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 5:01:33
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// c++20
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	// [실습] 연산자 오버로딩을 더 잘 이해하고 코딩하자
	// 문제
	// 다음 문장이 문제없이 실행되도록 하라
	
	sort(s.begin(), s.end());

	cout << s << endl; //0123456789
 }


==================================================
FileName.cpp, 저장시간: 2024-05-09 목요일 오후 5:01:40
==================================================

//-----------------------
//목78
// 5.6 화
// 
// Iterator - Iterators are a generalization of pointers.
//			- 포인터를 일반화 한 것이 반복자다.
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자>
void f(반복자 iter) {
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// c++20
	cout << typeid(반복자::iterator_concept).name() << endl;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	// [실습] 연산자 오버로딩을 더 잘 이해하고 코딩하자
	// 문제
	// 다음 문장이 문제없이 실행되도록 하라
	
	sort(s.begin(), s.end());

	cout << s << endl; //0123456789
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 1:58:20
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v ) {
	while (!(b == e)) {
		if (*b == v)
			return b;
		else
			++b;
	}


	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	// 문제
	// 사용자가 원하는 char를 찾는다
	
	while (true) {
		cout << "찾을 글자 입력 >>  ";
		char c;
		cin >> c;

		auto p = my_find(s.begin(), s.end(), c);

		if (p != s.end()) {
			cout << c << "는 s의 " << p - s.begin() + 1 << "번째 글자" << endl;
		}
		else
			cout << c << "는 없음" << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 1:58:37
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v ) {
	while (!(b == e)) {
		if (*b == v)
			return b;
		else
			++b;
	}


	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	// 문제
	// 사용자가 원하는 char를 찾는다
	
	while (true) {
		cout << "찾을 글자 입력 >>  ";
		char c;
		cin >> c;

		auto p = my_find(s.begin(), s.end(), c);

		if (p != s.end()) {
			cout << c << "는 s의 " << p - s.begin() + 1 << "번째 글자" << endl;
		}
		else
			cout << c << "는 없음" << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:11:44
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 조건식>
반복자 my_find_if(반복자 b, 반복자 e, 조건식 c) {  // 조건식 predicate
	while (!(b == e)) {
		if (c(*b))
			return b;
		else
			++b;
	}

	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	// 문제
	// my_find_if
	// 짝수를 찾는다
	
	auto p = my_find_if(s.begin(), s.end(),
		[](char c) {
			if (isdigit(c)) {
				if (c & 1)
					return false;
				return true;
			}
		});


	if (p != s.end()) 
		cout << "s의 " << p - s.begin() + 1 << "번째 글자는 짝수: " << *p << endl;
	else
		cout << "짝수는 없음" << endl;
	
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:12:00
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 조건식>
반복자 my_find_if(반복자 b, 반복자 e, 조건식 c) {  // 조건식 predicate
	while (!(b == e)) {
		if (c(*b))
			return b;
		else
			++b;
	}

	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "1357924680" };

	// 문제
	// my_find_if
	// 짝수를 찾는다
	
	auto p = my_find_if(s.begin(), s.end(),
		[](char c) {
			if (isdigit(c)) {
				if (c & 1)
					return false;
				return true;
			}
		});


	if (p != s.end()) 
		cout << "s의 " << p - s.begin() + 1 << "번째 글자는 짝수: " << *p << endl;
	else
		cout << "짝수는 없음" << endl;
	
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:14:58
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 조건식>
반복자 my_find_if(반복자 b, 반복자 e, 조건식 c) {  // 조건식 predicate
	while (!(b == e)) {
		if (c(*b))
			return b;
		else
			++b;
	}

	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "135792468020240513" };

	// 문제
	// my_find_if
	// 모든 짝수를 찾는다
	
	auto p = my_find_if(s.begin(), s.end(),
		[](char c) {
			if (isdigit(c)) {
				if (c & 1)
					return false;
				return true;
			}
		});

	auto it = p;

	while (it != s.end()) {
		++it;

		it = my_find_if(s.begin(), s.end(),
			[](char c) {
				if (isdigit(c)) {
					if (c & 1)
						return false;
					return true;
				}
			});
		
		if (it != s.end()) {
			cout << *it << endl;
			++it;
		}
	}


	/*if (p != s.end()) 
		cout << "s의 " << p - s.begin() + 1 << "번째 글자는 짝수: " << *p << endl;
	else
		cout << "짝수는 없음" << endl;*/
	
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:16:02
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 조건식>
반복자 my_find_if(반복자 b, 반복자 e, 조건식 c) {  // 조건식 predicate
	while (!(b == e)) {
		if (c(*b))
			return b;
		else
			++b;
	}

	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "135792468020240513" };

	// 문제
	// my_find_if
	// 모든 짝수를 찾는다
	
	auto p = my_find_if(s.begin(), s.end(),
		[](char c) {
			if (isdigit(c)) {
				if (c & 1)
					return false;
				return true;
			}
		});

	/*while (it != s.end()) {
		++it;

		it = my_find_if(s.begin(), s.end(),
			[](char c) {
				if (isdigit(c)) {
					if (c & 1)
						return false;
					return true;
				}
			});
		
		if (it != s.end()) {
			cout << *it << endl;
			++it;
		}
	}*/

	auto it = p;

	for (it = p; it != s.end(); ++it) {
		it = my_find_if(s.begin(), s.end(),
			[](char c) {
				if (isdigit(c)) {
					if (c & 1)
						return false;
					return true;
				}
			});

		if (it != s.end()) {
			cout << *it << endl;
		}
	}


	/*if (p != s.end()) 
		cout << "s의 " << p - s.begin() + 1 << "번째 글자는 짝수: " << *p << endl;
	else
		cout << "짝수는 없음" << endl;*/
	
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:34:38
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 조건식>
반복자 my_find_if(반복자 b, 반복자 e, 조건식 c) {  // 조건식 predicate
	while (!(b == e)) {
		if (c(*b))
			return b;
		else
			++b;
	}

	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "135792468020240513" };

	// 문제
	// my_find_if
	// 모든 짝수를 찾는다
	
	auto p = my_find_if(s.begin(), s.end(),
		[](char c) {
			if (isdigit(c)) {
				if (c & 1)
					return false;
				return true;
			}
		});

	auto beg = s.begin();

	while (beg != s.end()) {
		auto p = my_find_if(beg, s.end(),
			[](char c) {
				if (isdigit(c)) {
					if (c & 1)
						return false;

					return true;
				}
				return false;
			});

		if (p != s.end())
			std::cout << *p << std::endl;

		beg = p + 1;
	}
	
	
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:35:09
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>

#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template <class 반복자, class 조건식>
반복자 my_find_if(반복자 b, 반복자 e, 조건식 c) {  // 조건식 predicate
	while (!(b == e)) {
		if (c(*b))
			return b;
		else
			++b;
	}

	return e;
}

int main() {
	save("FileName.cpp");

	String s{ "135792468020240513" };

	// 문제
	// my_find_if
	// 모든 짝수를 찾는다
	
	auto p = my_find_if(s.begin(), s.end(),
		[](char c) {
			if (isdigit(c)) {
				if (c & 1)
					return false;
				return true;
			}
		});

	auto beg = s.begin();

	while (beg != s.end()) {
		auto p = my_find_if(beg, s.end(),
			[](char c) {
				if (isdigit(c)) {
					if (c & 1)
						return false;

					return true;
				}
				return false;
			});

		if (p != s.end())
			std::cout << *p << std::endl;

		else {
			break;
		}

		beg = p + 1;
	}
	
	
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:42:41
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector<char>v;

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:43:04
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;

		++b;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector<char>v;

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:43:19
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;

		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector<char>v;

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:44:37
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector<char>v;

	my_copy(s.begin(), s.end(), ostream_iterator<char>{cout});
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:46:29
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;

	//my_copy(s.begin(), s.end(), v.begin(), v.end());

	for (char c : v)
		cout << c;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:46:41
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;

	my_copy(s.begin(), s.end(), v.begin());

	for (char c : v)
		cout << c;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:47:03
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d, OutIter d2) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;

	my_copy(s.begin(), s.end(), v.begin(), v.end());

	for (char c : v)
		cout << c;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:49:01
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;
	v.reserve(100);

	my_copy(s.begin(), s.end(), v.begin());

	for (char c : v)
		cout << c;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:49:21
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;
	//v.reserve(100);

	my_copy(s.begin(), s.end(), v.begin());

	for (char c : v)
		cout << c;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:51:07
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;
	v.reserve(100);

	my_copy(s.begin(), s.end(), v.begin());

	for (int i = 0; i != s.get_len(); ++i)
		cout << v[i];
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:53:59
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d, OutIter d2) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
	*d2 = *e;
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;
	v.reserve(100);

	my_copy(s.begin(), s.end(), v.begin(), v.end());

	for (char c : v)
		cout << c;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 2:56:26
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 알고리즘 함수 - 반복자를 인자로 받는다
// 
// 
// 6월 6일 목요일 강의 예정
//----------------------
#include <iostream>
#include <vector>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class InIter, class OutIter>
void my_copy(InIter b, InIter e, OutIter d) {
	while (!(b == e)) {
		*d = *b;
		++b;
		++d;
	}
}

int main() {
	save("FileName.cpp");

	String s{ "2024년 5월 13일 졸업작품 중간발표" };
	vector <char> v;
	v.reserve(100);

	my_copy(s.begin(), s.end(), back_inserter(v));

	for (char c : v)
		cout << c;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 3:16:00
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set
//----------------------
#include <iostream>
#include <set>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	set<String> s{ istream_iterator<String>{cin}, {} };
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 3:16:52
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set
//----------------------
#include <iostream>
#include <set>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s) {
		cout << s << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 3:17:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set
//----------------------
#include <iostream>
#include <set>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 3:17:44
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set
//----------------------
#include <iostream>
#include <set>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라
	관찰 = true;

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-13 월요일 오후 3:18:00
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set
//----------------------
#include <iostream>
#include <set>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라
	관찰 = true;

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:44:19
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라
	관찰 = true;

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:44:41
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:44:58
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:45:52
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	set<String> s{ istream_iterator<String>{cin}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:52:50
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	fstream in{ "FileName.cpp" };
	set<String, less<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:55:11
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//키보드 입력을 받아 저장한 후 정렬하여 출력하라

	fstream in{ "FileName.cpp" };
	multiset<String, less<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:59:33
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, greater<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 3:59:48
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, greater<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:01:05
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, greater<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:03:26
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, greater<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:03:34
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, greater<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:03:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, less<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:04:01
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, less<String>> s{ istream_iterator<String>{in}, {} };

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:08:13
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

bool 길이오름차순(const String& a, const String& b) {
	return a.get_len() > b.get_len();
}

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, bool(*)(const String& a, const String& b)> 
		s{istream_iterator<String>{in}, {}, 길이오름차순};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:08:29
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

bool 길이오름차순(const String& a, const String& b) {
	return a.get_len() < b.get_len();
}

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, bool(*)(const String& a, const String& b)> 
		s{istream_iterator<String>{in}, {}, 길이오름차순};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:11:03
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다
// uniqueness - equivalent한 자료는 제외한다
// equivalence - A, B의 순서를 정할 때 A, B의 순서를 결정할 수 없다
//				!(A < B) && !(B < A)
// 
// String을 길이 순으로 정렬한다고 해본다
// {1, 22, 333, A, BB, CCC}
// 
// 1, A는 동등한 자격을 갖는다
// 22, BB도 동등한 자격을 갖는다
// 
// 이 경우 set에는 {1, 22, 333}만 저장된다
// 
// 
// equality(상등) - A, B가 operator==()의 결과 true이다.
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

struct 길이오름차순 {
public: 
	bool operator()(const String& a, const String& b) const {
		return a.get_len() < b.get_len();
	}
};

int main() {
	save("FileName.cpp");

	//문제
	//s가 길이 오름차순으로 정렬하게 하라

	fstream in{ "FileName.cpp" };
	multiset<String, 길이오름차순 > 
		s{istream_iterator<String>{in}, {}};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:23:27
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

// set이 영문자와 한글을 분리하게 한다
// 이렇게 하면 절대 안된다
template<>
struct less <String> {
	bool operator() (const String& a, const String& b) const {
		// a/b - 영/영, 영/x, x/x
		//x/영 일때만 순서를 바꾸도록 지시
		if (!isalpha(*(a.begin())) && isalpha(*(b.begin()))){
			return false;
		}
		return true;
	}
};

int main() {
	save("FileName.cpp");

	//문제
	//s는 첫 글자가 영문자 알파벳 인것과 그렇지 않은 것으로 분리한다.

	fstream in{ "FileName.cpp" };
	multiset<String, less<String>> s{istream_iterator<String>{in}, {}};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:45:52
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

// set이 영문자와 한글을 분리하게 한다
// 이렇게 하면 절대 안된다
template<>
struct less <String> {
	bool operator() (const String& a, const String& b) const {
		// a/b - 영/영, 영/x, x/x
		//x/영 일때만 순서를 바꾸도록 지시
		if (!isalpha(*(a.begin())) && isalpha(*(b.begin()))){
			return false;
		}
		return true;
	}
};

int main() {
	save("FileName.cpp");

	//문제
	//s는 첫 글자가 영문자 알파벳 인것과 그렇지 않은 것으로 분리한다.

	fstream in{ "이상한 나라의 엘리스.txt" };
	multiset<String, less<String>> s{istream_iterator<String>{in}, {}};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:46:05
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

// set이 영문자와 한글을 분리하게 한다
// 이렇게 하면 절대 안된다
template<>
struct less <String> {
	bool operator() (const String& a, const String& b) const {
		// a/b - 영/영, 영/x, x/x
		//x/영 일때만 순서를 바꾸도록 지시
		if (!isalpha(*(a.begin())) && isalpha(*(b.begin()))){
			return false;
		}
		return true;
	}
};

int main() {
	save("FileName.cpp");

	//문제
	//s는 첫 글자가 영문자 알파벳 인것과 그렇지 않은 것으로 분리한다.

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String, less<String>> s{istream_iterator<String>{in}, {}};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:46:29
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

// set이 영문자와 한글을 분리하게 한다
// 이렇게 하면 절대 안된다
template<>
struct less <String> {
	bool operator() (const String& a, const String& b) const {
		// a/b - 영/영, 영/x, x/x
		//x/영 일때만 순서를 바꾸도록 지시
		if (!isalpha(*(a.begin())) && isalpha(*(b.begin()))){
			return false;
		}
		return true;
	}
};

int main() {
	save("FileName.cpp");

	//문제
	//s는 첫 글자가 영문자 알파벳 인것과 그렇지 않은 것으로 분리한다.

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> s{istream_iterator<String>{in}, {}};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:46:43
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

// set이 영문자와 한글을 분리하게 한다
// 이렇게 하면 절대 안된다
template<>
struct less <String> {
	bool operator() (const String& a, const String& b) const {
		// a/b - 영/영, 영/x, x/x
		//x/영 일때만 순서를 바꾸도록 지시
		if (!isalpha(*(a.begin())) && isalpha(*(b.begin()))){
			return false;
		}
		return true;
	}
};

int main() {
	save("FileName.cpp");

	//문제
	//s는 첫 글자가 영문자 알파벳 인것과 그렇지 않은 것으로 분리한다.

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> s{istream_iterator<String>{in}, {}};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:47:30
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{istream_iterator<String>{in}, {}};

	for (const auto& s : s)
		cout << s << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:48:48
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	set<String> s{istream_iterator<String>{in}, {}};

	for (const auto& word : s)
		cout << word << "   ";

	cout << endl;

	cout << "단어 개수는 " << s.size();
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 4:50:51
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> s{istream_iterator<String>{in}, {}};

	for (const auto& word : s)
		cout << word << "   ";

	cout << endl;

	cout << "단어 개수는 " << s.size();
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 5:11:23
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};
	cout << "단어 개수는 " << s.size();

	// 문제
	// 찾는 단어가 이 소설에 있나 알아보라

	while (true) {
		cout << "찾을 단어 >> ";
		string word;
		cin >> word;

		auto it = s.contains(word);

		if (it)
			cout << word << "는 존재함" << endl;

		else
			cout << word << "는 존재하지 않음" << endl;
			
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 5:17:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			if (includes(word.begin(), word.end(), search.begin(), search.end()))
				cout << word << endl;
		}
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-16 목요일 오후 5:17:57
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			if (includes(word.begin(), word.end(), search.begin(), search.end()))
				cout << word << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:24:15
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			if (includes(word.begin(), word.end(), search.begin(), search.end()))
				cout << word << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:24:28
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			if (includes(word.begin(), word.end(), search.begin(), search.end()))
				cout << word << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:28:09
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			auto it = s.find(search);
			if (it != s.end())
				cout << *it << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:28:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			auto it = s.find(search);
			if (it != s.end()) {
				cout << *it << endl;
				break;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:29:55
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			if (word == search)
				cout << word << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:39:58
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			if (includes(word.begin(), word.end(), search.begin(), search.end()))
				cout << word << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:40:02
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> s{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string search;
		cin >> search;

		for (const auto& word : s) {
			if (includes(word.begin(), word.end(), search.begin(), search.end()))
				cout << word << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:45:13
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());
			if (it != word.end()) {
				cout << word << " ";
			}
			cout << endl << endl;
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:45:29
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());
			if (it != word.end()) {
				cout << word << " ";
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:46:04
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());
			if (it != word.end()) {
				cout << word << " ";
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:48:45
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	string buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:49:26
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	string buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:51:50
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	String buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:51:54
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	String buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:52:01
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	String buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:52:20
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	String buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:52:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	string buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:54:16
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	string buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:54:34
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	string buffer{};

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				if(buffer != word)
					cout << word << " ";

				buffer = word;
			}
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:56:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<string> ms{istream_iterator<string>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		string s;
		cin >> s;

		set<string> found;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				found.insert(word);
			}
		}

		for (const auto& word : found)
			cout << word << " ";

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:57:18
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		set<String> found;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				found.insert(word);
			}
		}

		if (found.size() > 0) {
			for (const auto& word : found)
				cout << word << " ";
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:57:41
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		set<String> found;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());

			if (it != word.end()) {
				found.insert(word);
			}
		}

		if (found.size() > 0) {
			for (const auto& word : found)
				cout << word << " ";
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:59:19
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		set<String> found;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());
			if (it != word.end())
				found.insert(word);
		}

		if (found.size() > 0) {
			for (const auto& word : found)
				cout << word << " ";
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:59:51
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		set<String> found;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());
			if (it != word.end())
				found.insert(word);
		}

		if (found.size() > 0) {
			for (const auto& word : found)
				cout << word << " ";
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 1:59:57
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 알파벳 단어가 들어가는 모든 단어를 출력하라
	// 같은 단어는 한 번만 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		set<String> found;

		for (const auto& word : ms) {
			auto it = search(word.begin(), word.end(), s.begin(), s.end());
			if (it != word.end())
				found.insert(word);
		}

		if (found.size() > 0) {
			for (const auto& word : found)
				cout << word << " ";
		}

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:07:58
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 단어가 있다면 몇 개가 있는지 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		auto it = ms.find(s);
		if (it != ms.end()) {
			cout << *it << " ";
			cout << ms.count(s) << "개"<< endl;
		}

		else
			cout << "단어가 없음" << endl;

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:17:38
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 단어가 있다면 몇 개가 있는지 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		auto [하한, 상한] = ms.equal_range(s);
		if (하한 == 상한)
			cout << "단어가 없음";

		else
			cout << distance(하한, 상한) << endl;

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:18:14
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 단어가 있다면 몇 개가 있는지 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		auto [하한, 상한] = ms.equal_range(s);
		if (하한 == 상한)
			cout << "단어가 없음";

		else
			cout << s << ": " << distance(하한, 상한) << endl;

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:19:02
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// set - unique 한 멤버의 set을 정렬된 상태로 관리한다

// set에 내가 정의한 클래스 String을 저장하려면
// 1. operator < 정의한다 - less<String> 객체가 호출 - operator < 
// 2. 함수 객체를 정의하고 set생성시 알려준다
//----------------------
#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	multiset<String> ms{istream_iterator<String>{in}, {}};

	// 문제
	// 찾는 단어가 있다면 몇 개가 있는지 출력하라

	while (true) {
		cout << "찾을 단어>> ";
		String s;
		cin >> s;

		auto [하한, 상한] = ms.equal_range(s);
		if (하한 == 상한)
			cout << "단어가 없음";

		else
			cout << s << ": " << distance(하한, 상한) << endl;

		cout << endl << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:45:51
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	map<String, list<String>> kpg{
		{"아이브", {"안유진", "가을", "레이", "장원영", "리즈", "이서"}}
	};
	
	kpg.insert(pair<String, list<String>>{{"씨스타19"}, { "보라", "효린" }});


	while (true) {
		cout << "그룹 검색 >> ";
		String group;
		cin >> group;

		auto it = kpg.find(group);
		if (it != kpg.end())
			cout << "있음" << endl;
		else
			cout << "없음" << endl;
	}
	
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:47:31
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	map<String, list<String>> kpg{
		{"아이브", {"안유진", "가을", "레이", "장원영", "리즈", "이서"}}
	};
	
	kpg.insert(pair<String, list<String>>{{"씨스타19"}, { "보라", "효린" }});


	while (true) {
		cout << "그룹 검색 >> ";
		String group;
		cin >> group;

		auto it = kpg.find(group);
		if (it != kpg.end())
			cout << "있음: " << it->first << endl;
		else
			cout << "없음" << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:48:27
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	map<String, list<String>> kpg{
		{"아이브", {"안유진", "가을", "레이", "장원영", "리즈", "이서"}}
	};
	
	kpg.insert(pair<String, list<String>>{{"씨스타19"}, { "보라", "효린" }});


	while (true) {
		cout << "그룹 검색 >> ";
		String group;
		cin >> group;

		auto it = kpg.find(group);
		if (it != kpg.end()) {
			cout << "있음: " << it->first << endl;
			for (const auto& member : it->second) {
				cout << member << " ";
			}
		}
		else
			cout << "없음" << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:48:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	map<String, list<String>> kpg{
		{"아이브", {"안유진", "가을", "레이", "장원영", "리즈", "이서"}}
	};
	
	kpg.insert(pair<String, list<String>>{{"씨스타19"}, { "보라", "효린" }});


	while (true) {
		cout << "그룹 검색 >> ";
		String group;
		cin >> group;

		auto it = kpg.find(group);
		if (it != kpg.end()) {
			cout << "있음: " << it->first << endl;
			for (const auto& member : it->second) {
				cout << member << " ";
			}
			cout << endl;
		}
		else
			cout << "없음" << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:49:22
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	map<String, list<String>> kpg{
		{"아이브", {"안유진", "가을", "레이", "장원영", "리즈", "이서"}}
	};
	
	kpg.insert(pair<String, list<String>>{{"씨스타19"}, { "보라", "효린" }});


	while (true) {
		cout << "그룹 검색 >> ";
		String group;
		cin >> group;

		auto it = kpg.find(group);
		if (it != kpg.end()) {
			cout << "있음: " << it->first << endl;
			for (const auto& member : it->second) {
				cout << member << " ";
			}
			cout << endl;
		}
		else
			cout << "없음" << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:49:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	map<String, list<String>> kpg{
		{"아이브", {"안유진", "가을", "레이", "장원영", "리즈", "이서"}}
	};
	
	kpg.insert(pair<String, list<String>>{{"씨스타19"}, { "보라", "효린" }});


	while (true) {
		cout << "그룹 검색 >> ";
		String group;
		cin >> group;

		auto it = kpg.find(group);

		if (it != kpg.end()) {
			cout << "있음: " << it->first << endl;
			for (const auto& member : it->second)
				cout << member << " ";
			cout << endl;
		}

		else
			cout << "없음" << endl;
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:50:57
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) exit(1);
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 2:51:04
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:03:24
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:03:45
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:03:53
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:04:05
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:04:10
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:04:12
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:04:15
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:04:16
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:04:18
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:11:51
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;

	map <int, char, less<int>> mp2;

	for (auto [alpha, num] : mp2)
		mp2[alpha] = num;

	for (const auto& m : mp2)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:12:00
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	//for (const auto& m : mp)
	//	cout << m.first << " - " << m.second << endl;

	map <int, char, less<int>> mp2;

	for (auto [alpha, num] : mp2)
		mp2[alpha] = num;

	for (const auto& m : mp2)
		cout << m.first << " - " << m.second << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:12:28
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	//for (const auto& m : mp)
	//	cout << m.first << " - " << m.second << endl;

	map <int, char, less<int>> mp2;

	for (auto [alpha, num] : mp2)
		mp2[alpha] = num;

	for (auto [alpha, num] : mp2)
		cout << alpha << " - " << num << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:12:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	//for (const auto& m : mp)
	//	cout << m.first << " - " << m.second << endl;

	map <int, char, less<int>> mp2;

	for (auto [alpha, num] : mp2)
		mp2[alpha] = num;

	for (auto [alpha, num] : mp2)
		cout << alpha << " - " << num << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:13:16
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	//for (const auto& m : mp)
	//	cout << m.first << " - " << m.second << endl;

	map <int, char, less<int>> mp2;

	for (auto [alpha, num] : mp2)
		mp2[num] = alpha;

	for (auto [alpha, num] : mp2)
		cout << alpha << " - " << num << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:13:28
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	//for (const auto& m : mp)
	//	cout << m.first << " - " << m.second << endl;

	map <int, char, less<int>> mp2;

	for (auto [alpha, num] : mp2)
		mp2[num] = alpha;

	for (auto [num, alpha] : mp2)
		cout << alpha << " - " << num << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:13:50
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	//for (const auto& m : mp)
	//	cout << m.first << " - " << m.second << endl;

	map <int, char, greater<int>> mp2;

	for (auto [alpha, num] : mp2)
		mp2[num] = alpha;

	for (auto [num, alpha] : mp2)
		cout << alpha << " - " << num << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:14:20
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에서 각 알파벳의 출현 횟수를 출력하라

	map<char, int> mp;

	char c{};

	while (in) {
		in >> c;
		if(isupper(c))
			c = tolower(c);

		++mp[c];

		mp.insert(pair<char, int>{c, mp[c]});
	}

	//for (const auto& m : mp)
	//	cout << m.first << " - " << m.second << endl;

	map <int, char, greater<int>> mp2;

	for (auto& [alpha, num] : mp2)
		mp2[num] = alpha;

	for (auto& [num, alpha] : mp2)
		cout << alpha << " - " << num << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:16:47
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에 사용된 단어와 횟수를 출력하라

	map<String, int> mp;

	String s{};

	while (in >> s) {
		mp[s]++;
		mp.insert(pair<String, int>{s, mp[s]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;

 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:17:58
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에 사용된 단어와 횟수를 출력하라

	map<String, int> mp;

	String s{};

	while (in >> s) {
		mp[s]++;
		mp.insert(pair<String, int>{s, mp[s]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;

	cout << "전체 단어 수: " << mp.size();

 }


==================================================
FileName.cpp, 저장시간: 2024-05-20 월요일 오후 3:18:24
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에 사용된 단어와 횟수를 출력하라

	map<String, int> mp;

	String s{};

	while (in >> s) {
		mp[s]++;
		mp.insert(pair<String, int>{s, mp[s]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;

	cout << "전체 단어 수: " << mp.size();

 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 3:42:06
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에 사용된 단어와 횟수를 출력하라

	map<String, int> mp;

	String s{};

	while (in >> s) {
		mp[s]++;
		mp.insert(pair<String, int>{s, mp[s]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;

	cout << "전체 단어 수: " << mp.size();

	// 많이 사용된 단어 먼저 출력하라
	map<int, String, greater<int>> mp2;

	for (const auto& [단어, 횟수] : mp)
		mp2.insert(make_pair(횟수, 단어));

	for (const auto& [개수, 단어] : mp2)
		cout << 단어 << "-" << 개수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 3:45:03
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <ranges>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에 사용된 단어와 횟수를 출력하라

	map<String, int> mp;

	String s{};

	while (in >> s) {
		mp[s]++;
		mp.insert(pair<String, int>{s, mp[s]});
	}

	for (const auto& m : mp)
		cout << m.first << " - " << m.second << endl;

	cout << "전체 단어 수: " << mp.size() << endl << endl;

	// 많이 사용된 단어 먼저 출력하라
	map<int, String, greater<int>> mp2;

	for (const auto& [단어, 횟수] : mp)
		mp2.insert(make_pair(횟수, 단어));

	for (const auto& [개수, 단어] : mp2 | views::reverse)
		cout << 단어 << "-" << 개수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 3:45:43
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <ranges>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에 사용된 단어와 횟수를 출력하라

	map<String, int> mp;

	String s{};

	while (in >> s) {
		mp[s]++;
		mp.insert(pair<String, int>{s, mp[s]});
	}

	cout << "전체 단어 수: " << mp.size() << endl << endl;

	// 많이 사용된 단어 먼저 출력하라
	map<int, String, greater<int>> mp2;

	for (const auto& [단어, 횟수] : mp)
		mp2.insert(make_pair(횟수, 단어));

	for (const auto& [개수, 단어] : mp2 
		| views::reverse 
		| views::take(20))
		cout << 단어 << "-" << 개수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 3:46:28
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <set>
#include <map>
#include <list>
#include <algorithm>
#include <fstream>
#include <string>
#include <ranges>
#include <array>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	fstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) return -1;

	// 문제
	// 파일에 사용된 단어와 횟수를 출력하라

	map<String, int> mp;

	String s{};

	while (in >> s) {
		mp[s]++;
		mp.insert(pair<String, int>{s, mp[s]});
	}

	cout << "전체 단어 수: " << mp.size() << endl << endl;

	// 많이 사용된 단어 먼저 출력하라
	multimap<int, String, greater<int>> mp2;

	for (const auto& [단어, 횟수] : mp)
		mp2.insert(make_pair(횟수, 단어));

	for (const auto& [개수, 단어] : mp2 
		| views::reverse 
		| views::take(20))
		cout << 단어 << "-" << 개수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:00:38
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{1, 99999};

int main() {
	save("FileName.cpp");

	//실습: uniform 분포는 정말 uniform한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i)
		iim[uid(dre) / 10000]++;

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:01:35
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{1, 99999};

int main() {
	save("FileName.cpp");

	//실습: uniform 분포는 정말 uniform한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 100000; ++i)
		iim[uid(dre) / 100000]++;

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:02:05
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{1, 99999};

int main() {
	save("FileName.cpp");

	//실습: uniform 분포는 정말 uniform한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 100000; ++i)
		iim[uid(dre) / 100000]++;

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:02:50
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{1, 99999};

int main() {
	save("FileName.cpp");

	//실습: uniform 분포는 정말 uniform한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 100000000; ++i)
		iim[uid(dre) / 100000000]++;

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:12:33
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{50000.};

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 10000)
			iim[(int)d / 10000]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:13:43
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{50000.};

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 100000)
			iim[(int)d / 10000]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:14:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{50000.};

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 100000)
			iim[(int)d / 100000 / 20]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:15:05
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{50000.};

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 100000)
			iim[(int)d / 100000 * 20]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:15:19
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{50000.};

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 100000)
			iim[(int)d / 5000]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:16:00
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 50000., 0.1 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 100000)
			iim[(int)d / 5000]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:16:30
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 50000., 0.01 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 100000)
			iim[(int)(d / 5000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:16:51
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 50000., 0.3 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre);
		if (0 < d && d < 100000)
			iim[(int)(d / 5000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:18:29
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 0.0, 0.1 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre) * 50000 + 50000;
		if (0 < d && d < 100000)
			iim[(int)(d / 5000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:18:57
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 0.0, 0.3 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre) * 50000 + 50000;
		if (0 < d && d < 100000)
			iim[(int)(d / 5000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:19:33
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 0.0, 0.0 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre) * 50000 + 50000;
		if (0 < d && d < 100000)
			iim[(int)(d / 5000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:20:05
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 0.0, 0.01 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre) * 50000 + 50000;
		if (0 < d && d < 100000)
			iim[(int)(d / 1000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:20:20
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 0.0, 0.05 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 10000; ++i) {
		double d = nd(dre) * 50000 + 50000;
		if (0 < d && d < 100000)
			iim[(int)(d / 1000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:20:41
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Associative container - set / map
// 
// map - <key, value> pair를 key 기준으로 정렬상태를 유지
//----------------------
#include <iostream>
#include <map>
#include <random>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

default_random_engine dre;
normal_distribution nd{ 0.0, 0.05 };

int main() {
	save("FileName.cpp");

	//실습: normal 분포는 정말 normal한가?
	map <int, int> iim;  // 구간과 횟수

	for (int i = 0; i < 1000000; ++i) {
		double d = nd(dre) * 50000 + 50000;
		if (0 < d && d < 100000)
			iim[(int)(d / 1000)]++;
	}

	for (const auto& [구간, 횟수] : iim)
		cout << 구간 << " - " << 횟수 << endl;
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:55:52
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	unordered_set<int> us{3, 1, 4, 2};

	for (const auto& num : us)
		cout << num << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:56:08
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	unordered_set<int> us{1, 2, 4, 3};

	for (const auto& num : us)
		cout << num << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:56:46
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	unordered_set<int> us{ 1, 2, 4, 3 };
	
	us.insert(7);

	for (const auto& num : us)
		cout << num << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:57:26
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	unordered_set<int> us{ 1, 2, 4, 3 };
	
	us.insert(8);

	for (const auto& num : us)
		cout << num << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 4:57:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

int main() {
	save("FileName.cpp");

	unordered_set<int> us{ 1, 2, 4, 3 };
	
	us.insert(9);

	for (const auto& num : us)
		cout << num << " ";
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:07:49
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_set<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:08:12
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_set<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:09:50
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_multiset<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:10:39
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_multiset<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:10:42
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_multiset<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:11:08
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_multiset<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:11:23
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_multiset<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }


==================================================
FileName.cpp, 저장시간: 2024-05-23 목요일 오후 5:11:55
==================================================

//-----------------------
//목78
// 5.6 화
// 
// 6월 6일 목요일 강의 예정
// 
// STL Unordered Associative container - unordered_set / unordered_map
// 
// 순서가 없다?
// 메모리 구조를 화면에 출력
// String을 unordered 컨테이너에 저장
//----------------------
#include <iostream>
#include <unordered_set>
#include <print>
#include "save.h"
#include "String.h" 
using namespace std;
extern bool 관찰;

template<class 언오더드셋>

void print_us(언오더드셋 us) {
	// unordered_set의 메모리를 화면에 출력한다
	for (int i = 0; i < us.bucket_count(); ++i) {
		print("[{:3}] ", i);

		for (auto p = us.begin(i); p != us.end(i); ++p)
			print(" - {}", *p);

		cout << endl;
	}
	cout << endl;
}

int main() {
	save("FileName.cpp");

	unordered_multiset<int> us{ 1, 2, 4, 3 };
	
	while (true) {
		print_us(us);

		cout << "추가 할 데이터 >> ";
		int num;
		cin >> num;
		cout << endl;

		us.insert(num);
	}
 }
